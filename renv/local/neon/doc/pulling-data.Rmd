---
title: "Pulling Data: A Detailed Guide"
output: 
  rmarkdown::html_vignette
editor_options:
  chunk_output_type: console
vignette: >
  %\VignetteIndexEntry{pulling-data}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

<style>
body, h1, h2, h3, h4 {
    font-family: "Roboto";
}
</style>

```{r setup, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
```

If you haven't already, please read the `installing-neon` and `getting-started` vignettes before proceeding. You can view them in a browser by typing `browseVignettes("neon")` or in RStudio with `vignette(<name_of_vignette>, package = "neon")`.

`pull_smartabase()` contains several arguments that aim to make your workflow easier. This vignette will explain what the following arguments mean and how they can be used

* [start_date / end_date / start_time / end_time](#date_time)
* [last](#last)
* [filter_user_key / filter_user_value](#filter_user_value)
* [filter_data_key / filter_data_value](#filter_data_value)
* [filter_data_condition](#filter_data_condition)
* [Putting it all together - filtering](#putting_together)
* [type](#type)
* [synchronise](#synchronise)
* [download_attachment](#download_attachment)
* [include_missing_users](#include_missing_users)
* [guess_col_type](#guess_col_type)
* [cloud_mode](#cloud_mode)
* [shiny_progress_code](#shiny_progress_code)

### start_date / start_time / end_date / end_time {#date_time}

Whenever you pull data from an event form, you must supply "dd/mm/yyyy" dates to the `start_date` and `end_date` arguments, or you must supply a string to the `last` argument, which is looked at in the next section. 

When supplying dates to the `start_date` and `end_date` arguments, only records that were entered between these dates will be downloaded.

You can also supply "h:mm AM" or "h:mm PM" values to the `start_time` and `end_time` arguments. Only records that were entered between these times will be downloaded. By default, `start_time` and `end_time` are ignored in the filtering process.

```{r metadata_example, eval = FALSE}
pull_smartabase(
  form       = "Example event form"
  start_date = "15/04/2019",
  end_date   = "31/04/2019",
  start_time = "9:15 AM",
  end_time   = "3:30 PM"
)
```

### last {#last}
If no dates are supplied to the `start_date` and `end_date` arguments, then you must supply a string to the `last` argument that indicates how many of the last *days*, *weeks*, *months* or *years* of data should be pulled for. For example, '7 days'. You can also simply supply the string 'today', which will download data with event dates equal to the current date. Note: if values are supplied to either `start_date` or `end_date`, `last` will be ignored.

```{r last_example, eval = FALSE}
pull_smartabase(
  form       = "Example event form",
  last       = "7 days"
)

pull_smartabase(
  form       = "Example event form",
  last       = "10 weeks"
)

pull_smartabase(
  form       = "Example event form",
  last       = "3 months"
)

pull_smartabase(
  form       = "Example event form",
  last       = "2 years"
)

pull_smartabase(
  form       = "Example event form",
  last       = "today"
)
```

### filter_user_key / filter_user_value {#filter_user_value}

`filter_user_key` and `filter_user_value` allow you to pull data for specific Smartabase users. If you don't supply values to these arguments, data will be pulled for all athletes you have access to. This can result in messy data with missing values; e.g.

```{r na_example, echo = FALSE, paged.print = TRUE}
n <- 2
dplyr::tibble(
  date               = c(rep(NA, n), "15/04/2019", rep(NA, n-1)),
  form               = "Example event form",
  user_id            = c(31808, 31811, 37201, 37204),
  about              = c("Charlie Thompson", "Jack Williams", "Jamie Anderson", "Liam Walker"),
  Distance           = c(rep(NA, n), 5411, rep(NA, n-1)),
  RPE                = c(rep(NA, n), 7, rep(NA, n-1)),
  entered_by_user_id = c(rep(NA, n), 37201, rep(NA, n-1))
)
```

To pull data for certain users, supply `filter_user_key` with the type of user identification you would like to use; i.e. 'about', 'user_id', 'username' or 'email'. `filter_user_value` then accepts the actual full names (i.e. about), user IDs, usernames or emails for the users you want to filter for.

See the examples below for more details, where we assume you have set up your credentials using `save_credentials()`.

##### Options

**about**

If `filter_user_key = "about"`, `filter_data_value` accepts *full names*.

```{r about_example, eval = FALSE}
pull_smartabase(
  form              = "Example event form",
  filter_user_key   = "about",
  filter_user_value = c("Aiden Thomas", "Jamie Anderson"),
  start_date        = "15/04/2019",
  end_date          = "31/04/2019"
)
```

**user_id**

If `filter_user_key = "user_id"`, `filter_data_value` accepts Smartabase *user IDs*.

```{r id_example, eval = FALSE}
pull_smartabase(
  form              = "Example event form",
  filter_user_key   = "user_id",
  filter_user_value = c(37204, 37201),
  start_date        = "15/04/2019",
  end_date          = "31/04/2019"
)
```

**username**

If `filter_user_key = "username"`, `filter_data_value` accepts Smartabase *usernames*.

```{r username_example, eval = FALSE}
pull_smartabase(
  form              = "Example event form",
  filter_user_key   = "username",
  filter_user_value = c("aiden.thomas", "jamie.anderson"),
  start_date        = "15/04/2019",
  end_date          = "31/04/2019"
)
```

**email**

If `filter_user_key = "email"`, `filter_data_value` accepts users' *emails*, as recorded on Smartabase.

```{r email_example, eval = FALSE}
pull_smartabase(
  form              = "Example event form",
  filter_user_key   = "email",
  filter_user_value = c("aiden.thomas@fusionsport.com", "jamie.anderson@fusionsport.com"),
  start_date        = "15/04/2019",
  end_date          = "31/04/2019"
)
```

**current_group**

If `filter_user_key = "current_group"`, the Smartabase API will look for whatever Smartabase group was loaded when you last logged into Smartabase. Data will then only be pulled for these users. `filter_user_value` is ignored.

```{r current_group_example, eval = FALSE}
pull_smartabase(
  form            = "Example event form",
  filter_user_key = "current_group",
  start_date      = "15/04/2019",
  end_date        = "31/04/2019"
)
```

**group**

If `filter_user_key = "group"`, `filter_data_value` accepts the name of a Smartabase `group`. Data will then only be pulled for users in that Smartabase group. 

```{r group_example, eval = FALSE}
pull_smartabase(
  form              = "Example event form",
  filter_user_key   = "group",
  filter_user_value = "Demo Users",
  start_date        = "15/04/2019",
  end_date          = "31/04/2019"
)
```

To see a list of Smartabase groups that you have access to, use the `get_group()` function. For more details, see the `helper-functions` vignette.

### filter_data_key / filter_data_value{#filter_data_value}

`filter_data_key` and `filter_data_value` allow you to filter the data according to certain rules.

For example, if you had a "Training Log" form with an "Duration" field, and you only want to pull data where Duration was equal to "35", your `pull_smartabase()` call may look like this

```{r filter_data1, eval = FALSE}
pull_smartabase(
  form              = "Training Log",
  filter_data_key   = "Duration",
  filter_data_value = "35",
  start_date        = "15/04/2019",
  end_date          = "31/04/2019"
)
```

As you can see, `filter_data_key` accepts the name of a field in your form of interest; in this case, "Duration". `filter_data_value` then accepts the Duration value you want to filter for; in this case, "35".

### filter_data_condition{#filter_data_condition}

By default, records that are *equal to* `filter_data_value` will be downloaded. However, you may want to pull records where, for example, Duration is greater than "35". You can achieve this by supplying "greater_than" to the `filter_data_condition` argument:

```{r filter_data_condition, eval = FALSE}
pull_smartabase(
  form                  = "Training Log",
  filter_data_key       = "Duration",
  filter_data_value     = "35",
  filter_data_condition = "greater_than" # alternatively, ">"
  start_date            = "15/04/2019",
  end_date              = "31/04/2019"
)
```

`filter_data_condition` accepts any of the following values

* "equal_to" or "="
* "not_equal_to" or "!="
* "greater_than" or ">"
* "less_than" or "<"
* "greater_than_or_equal_to" or ">="
* "less_than_or_equal_to" or "<="
* "contains" or "%in%"

Note that the greater_than, greater_than_or_equal_to, less_than and less_than_or_equal_to operators will only work on number fields.

You may also use multiple filters in the same call to `pull_smartabase()`. Keep in mind that when using multiple filters, only rows that match all conditions will be returned. So for instance, in the below example, the only records that would be returned are those where Duration is below 25 AND where RPE is also greater than or equal to 6:

```{r length_example1, eval = FALSE}
pull_smartabase(
  form                  = "Training Log",
  filter_data_key       = c("Duration", "RPE"),
  filter_data_value     = c("25", "6"),
  filter_data_condition = c("<", ">="), # alternatively, c("less_than", "greater_than_or_equal_to")
  start_date            = "15/04/2019",
  end_date              = "31/04/2019"
)
```

Note that `filter_data_key`, `filter_data_condition` and `filter_data_value` must be the same length, although in certain situations `pull_smartabase()` will try to ensure they are the same length for you, as outlined below.

1. There cannot be duplicate `filter_data_key` elements, e.g. `filter_data_key = c("Duration", "Duration")`. This makes sense when you think about it, since no record can match multiple conditions for the same field. It follows from this that when `field_data_key` is length == 1, then `filter_data_condition` and `filter_data_value` must both be length == 1.
2. If `filter_data_key` is length > 1, is the same length as `filter_data_condition`, and `filter_data_value` is length == 1, then `filter_data_value` will be replicated to match the length of `filter_data_key`. 
3. If `filter_data_key` is length > 1, is the same length as `filter_data_value`, and `filter_data_condition` is length == 1, then `filter_data_condition` will be replicated to match the length of `filter_data_key`.
4. Finally, if `filter_data_key` is length > 1 and both `filter_data_condition` and `filter_data_value` are length == 1, then `filter_data_condition` and `filter_data_value` will be replicated to match the length of `filter_data_key`.

Below are some examples to make it clearer. The first example is a valid query and will return records where both Duration and RPE are less than 6.

```{r length_example2, eval = FALSE}
pull_smartabase(
  form                  = "Training Log",
  filter_data_key       = c("Duration", "RPE"),
  filter_data_value     = c("25", "6")
  filter_data_condition = c("<")
  start_date            = "15/04/2019",
  end_date              = "31/04/2019"
)
```

Likewise, below is another valid query that will return records where Duration and RPE are both equal to 7 (since `filter_data_condition` defaults to "equal_to")

```{r length_example3, eval = FALSE}
pull_smartabase(
  form                  = "Training Log",
  filter_data_key       = c("Duration", "RPE"),
  filter_data_value     = c("7"),
  start_date            = "15/04/2019",
  end_date              = "31/04/2019"
)
```

The next example will return an error, since there is only one element in `filter_data_key` but multiple elements in `filter_data_value`. If `pull_smartabase()` replicated `filter_data_key` to be the same length as `filter_data_value`, it would result in duplicate elements in `filter_data_key`, which is not possible.

```{r length_example4, eval = FALSE}
pull_smartabase(
  form                  = "Training Log",
  filter_data_key       = c("Duration"),
  filter_data_value     = c("7", "25"),
  start_date            = "15/04/2019",
  end_date              = "31/04/2019"
)
```

Finally, the next example will also return an error since `filter_data_condition` has length == 3 whereas `filter_data_key` and `filter_data_value` have length == 2.

```{r length_example5, eval = FALSE}
pull_smartabase(
  form                  = "Training Log",
  filter_data_key       = c("Duration", "RPE"),
  filter_data_condition = c("=", "<", ">=")
  filter_data_value     = c("7", "25"),
  start_date            = "15/04/2019",
  end_date              = "31/04/2019"
)
```

### Putting it all together - filtering {#putting_together}

Below are some examples of filtering for both multiple users and multiple conditions in the one `pull_smartabase()` call.

Imagine we want to pull data from a Training Log form that has a Duration field and an RPE field

```{r training_log, echo = FALSE, out.extra = 'style="border:0;"'}
knitr::include_graphics("../man/figures/training_log.png")
```

#### Example 1

If we want to filter for 1) "Aiden Thomas" and "Jamie Anderson", using their emails, and 2) records where Duration is less than "25" minutes and RPE is greater than or equal to "6", then our `pull_smartabase()` call would look like this

```{r putting_together1, eval = FALSE}
pull_smartabase(
  form                  = "Training Log",
  filter_user_key       = "email",
  filter_user_value     = c("aiden.thomas@fusionsport.com", "jamie.anderson@fusionsport.com"),
  filter_data_key       = c("Duration", "RPE"),
  filter_data_value     = c("25", "6"),
  filter_data_condition = c("<", ">="), # alternatively, c("less_than", "greater_than_or_equal_to")
  start_date            = "15/04/2019",
  end_date              = "31/04/2019"
)
```

#### Example 2

Let's say we now want to pull data for 1) "Aiden Thomas" and "Jamie Anderson", using their full names and 2) records where Duration is *not equal* to "50" minutes and RPE *contains* the word "Hard"

```{r putting_together2, eval = FALSE}
pull_smartabase(
  form                  = "Training Log",
  filter_user_key       = "email",
  filter_user_value     = c("Aiden Thomas", "Jamie Anderson"),
  filter_data_key       = c("Duration", "RPE"),
  filter_data_value     = c("50", "Hard"),
  filter_data_condition = c("!=", "%in%"), # alternatively, c("not_equal_to", "contains")
  start_date            = "15/04/2019",
  end_date              = "31/04/2019"
)
```

### type {#type}

By default, `pull_smartabase()` expects to pull data from an event form, so `type = "event"`. To pull from a profile form, set `type = "profile"`.

```{r profile_example, eval = FALSE}
pull_smartabase(
  form              = "Example profile form",
  type              = "profile",
  filter_user_key   = "about",
  filter_user_value = c("Aiden Thomas", "Jamie Anderson"),
  start_date        = "15/04/2019",
  end_date          = "31/04/2019"
)
```

`type` can also be set to `type = "synchronise"`, which will be looked at in the next section.

### synchronise {#synchronise}

Setting `type = "synchronise"` is a way to determine which records have been entered into a Smartabase form after a certain time. Here is the general workflow for synchronising with a Smartabase form.

The first time you synchronise, your `pull_smartabase()` call might look like this:

```{r synchronise_example, eval = FALSE}
synchronise_example <- pull_smartabase(
  form       = "Example profile form",
  type       = "synchronise",
  start_date = "15/04/2019",
  end_date   = "31/04/2019"
)
```

This will return a list with three elements. The first element will be all the records that exist in the form; the second element will be the current time (unix time); and the third element will the event ID of all records that have been deleted from that form.

```{r synchronise_example2, echo = FALSE}
synchronise_example <- list(new_data = dplyr::tibble(
  about              = c("Charlie Thompson", "Jack Williams", "Jamie Anderson", "Liam Walker"),
  user_id            = c(31808, 31811, 37201, 37204),
  form               = c("Example event form", "Example event form", "Example event form", "Example event form"),
  start_date         = c("15/04/2019", "15/04/2019", "15/04/2019", "15/04/2019"),
  Distance           = c(5411, 2374, 1600, 2564),
  RPE                = c(7, 3, 6, 5),
  entered_by_user_id = c(37201, 37201, 37201, 37201),
  event_id           = c(16517, 36505, 36014, 28970)
),
last_sync_time = as.numeric(formatC(1588855000000, format = "e", digits = 6)),
deleted_events = c(991, 992, 993)
)
```

```{r synchronise_example3, echo = TRUE}
print(synchronise_example)
```

Now, the next time you synchronise with that form, you can use the last_sync_time to determine any new records that have been entered into that form since the last time you synched (i.e., the events that have been entered into the form after the last_sync_time).

```{r synchronise_example4, eval = FALSE}
next_sync_example <- pull_smartabase(
  form           = "Example profile form",
  type           = "synchronise",
  last           = "1 years",
  start_date     = "15/04/2019",
  end_date       = "31/04/2019",
  last_sync_time = synchronise_example$last_sync_time
)
```

```{r synchronise_example5, echo = FALSE}
next_sync_example <- list(new_data = dplyr::tibble(
  about              = c("Jamie Anderson"),
  user_id            = c(37201),
  form               = c("Example event form"),
  start_date         = c("18/04/2019"),
  Distance           = c(3100),
  RPE                = c(7),
  entered_by_user_id = c(37201),
  event_id           = c(62331)
),
last_sync_time = as.numeric(formatC(1588856000000, format = "e", digits = 6)),
deleted_events = NULL
)
```

```{r synchronise_exmaple6, echo = TRUE}
print(next_sync_example)
```

So why is this useful? By querying which records have been entered into a form beyond a certain time, you can set up workflows that automatically trigger R scripts whenever new data is detected. For more information on how to achieve this, contact Fusion Sport.

### download_attachment{#download_attachment}

If you are pulling from a form that contains a file upload field, then you can download those files to your local machine by setting the `download_attachment = TRUE`. When you then run `pull_smartabase()`, you will not only retrieve the data that lives in the form, but the files that were uploaded to the file upload field/s will be downloaded to your current directory. 

```{r download_attachment1, echo = TRUE, eval = FALSE}
pull_smartabase(
  form                = "Example form",
  download_attachment = TRUE
  start_date          = "15/04/2019",
  end_date            = "31/04/2019"                
)
```

```{r download_attachment3, echo = FALSE}
cat("Example form is downloading...") 
cat("|===================================================================| 100%")
cat("Dowloading 1 attachment from Example form...")
message("Authentication success: (200) ok")
message("Example form download successful: 1 rows retrieved")
message("Example form attachment download successful: 1 out of 1 files (1mb total) saved to C:/Users/ZacPross/Example_directory")
```

```{r download_attachment2, echo = FALSE, eval = TRUE}
dplyr::tibble(
  about              = c("Jamie Anderson"),
  user_id            = c(37201),
  form               = c("Example event form"),
  start_date         = c("18/04/2019"),
  File               = "1234|Example_file.csv",
  Distance           = c(3100),
  RPE                = c(7),
  entered_by_user_id = c(37201),
  event_id           = c(62331),
  file_name          = c("Example Event Form_ZacPross_08062020_900PM_Example_file.csv"),
  attachment_url     = "https://example.smartabase.com//x/FileDownloadServlet?id=b1b234f1-ccd7-4b12-a4fa-123456beb0&token=123456789101112",
  name               = "Example_file.csv"
)
```

### include_missing_users{#include_missing_users}

By default, data will be pulled only for those users who have entered data in the form of interest while accounting for the filtering conditions. However, there may be instances where you want to see which users have not entered any data -- for instance, for data quality analysis purposes. To do this, simply set `include_missing_users = TRUE` and all users that meet your user filtering conditions will be included in the returned data frame, however they will appear as a row of NA values.

```{r include_missing_users1, echo = FALSE}
include_missing_user_data <- 
  dplyr::tibble(
    about              = c("Charlie Thompson", "Jack Williams", "Jamie Anderson", "Liam Walker"),
    user_id            = c(31808, 31811, 37201, 37204),
    form               = c("Example event form", "Example event form", NA, NA),
    start_date         = c("15/04/2019", "15/04/2019", NA, NA),
    Distance           = c(5411, 2374, NA, NA),
    RPE                = c(7, 3, NA, NA),
    entered_by_user_id = c(37201, 37201, NA, NA),
    event_id           = c(16517, 36505, NA, NA)
  )
```

```{r include_missing_users2, echo = FALSE}
include_missing_user_data
```

Above, users 3 and 4 (Jamie Anderson and Liam Walker) haven't entered any data.

### guess_col_type{#guess_col_type}

By default, `pull_smartabase()` guesses the data type of each column and appends the guess to the top of each column. For example,

```{r guess_col_type1, echo = TRUE, eval = FALSE}
pull_smartabase(
  form              = "Training Log",
  start_date        = "15/04/2019",
  end_date          = "15/04/2019",
  filter_user_key   = "about",
  filter_user_value = "Charlie Thompson"
)
```

```{r guess_col_type2, echo = FALSE}
dplyr::tibble(
  about              = c("Charlie Thompson"),
  user_id            = c(31808),
  form               = c("Example event form"),
  start_date         = c("15/04/2019"),
  `Date of Session`  = "15/04/2019",
  Distance           = c(5411),
  RPE                = c(7),
  entered_by_user_id = c(37201),
  event_id           = c(16517)
)
```

Notice how in the tibble above the `about` column has `<chr>` at the top (meaning that the column contains character data) and the `Distance` column has `<dbl>` at the top (meaning that the column contains numeric data).

However, if you do not want `pull_smartabase()` to guess the column types and would like everything to come through as character types, simply set `guess_col_type = FALSE`.

```{r guess_col_type3, echo = TRUE, eval = FALSE}
pull_smartabase(
  form              = "Training Log",
  start_date        = "15/04/2019",
  end_date          = "15/04/2019",
  filter_user_key   = "about",
  filter_user_value = "Charlie Thompson",
  guess_col_type    = FALSE
)
```

```{r guess_col_type4, echo = FALSE}
dplyr::tibble(
  about              = c("Charlie Thompson"),
  user_id            = c(31808),
  form               = c("Example event form"),
  start_date         = c("15/04/2019"),
  `Date of Session`  = "1555288875000",
  Distance           = c("5411"),
  RPE                = c("7"),
  entered_by_user_id = c(37201),
  event_id           = c(16517)
)
```

Notice how the `Distance` column is now `<chr>`, whereas before it was `<dbl>`.

A few other things to note:

1. The metadata columns `user_id`, `entered_by_user_id` and `event_id` are not affected by the `guess_col_type` argument -- they will always come through as numeric.
2. `Date of Session` is actually a Smartabase date field and so
+ When `guess_col_type = FALSE`, all Smartabase date fields are pulled through in the form of "epoch type"; that is, the number of milliseconds that have elapsed since 00:00:00, 1 January 1970. 
+ When `guess_col_type = TRUE`, `pull_smartabase()` searches for any field names with the word "date" in it whose values are a string of digits. If your local machine is set to American time, this date will be converted to mm/dd/yyyy format; machines in other timezones will return dd/mm/yyyy format. Therefore, if you desire non-event date fields to display a regular date format, it is imperative that `guess_col_type = TRUE`, the field name on Smartabase contains the word "date" in it and that your computer's timezone is set correctly.
3. Event dates, converted Smartabase date fields or any Smartabase fields that contain some kind of date data will always be pulled as character types. The reason for this is that if you want to push date data back up to Smartabase, it must be character type (i.e. required by the Smartabase API). 

### cloud_mode {#cloud_mode}

`pull_smartabase()` accepts an input called `cloud_mode`. If `cloud_mode = TRUE`, no progress bar will be printed to screen. This is for when the package is being run on cloud instances in an automated fashion. Furthermore, any error logs are printed rather than saved to a text file.

### shiny_progress_code {#shiny_progress_code}

You will notice that when you pull data into RStudio with pull_smartabase(), a progress bar will appear in the console that roughly displays the percentage of data left to download. 

It would be useful if this progress bar can be passed to shiny apps that utilise pull_smartabase(), given the typical way to show progress bars in shiny is to essentially fake it; that is, to step the progress bar according to some arbitrary function that doesn't actually represent the state of the download â€“ see [here](https://shiny.rstudio.com/articles/progress.html).

The problem is that the progress bar in pull_smartabase() is printed to screen, but to work with a shiny app it needs to accept the shiny app's session ID. Thankfully, there is a package called `shinyhttr` that achieves this: [shinyhttr github](https://github.com/curso-r/shinyhttr).

To pass the progress bar to a shinyapp, you firstly must install `shinyhttr` and `shinyWidgets` and load them in your app. Second, you must pass the bare `shinyhttr` code for producing a shiny progress bar to the `shiny_progress_code` argument in `pull_smartabase()`. Let's say you also have a button called `get_data` in your app, where clicking on that button triggers `pull_smartabase()`. Your reactive function for pulling data in a shiny app might then look like this:

```{r shiny_progress_code_example, eval = FALSE}
input_data <- eventReactive(input$get_data, {
  pull_smartabase(
    form = "Example form",
    start_date = "15/04/2019",
    end_date = "30/04/2019",
    shiny_progress_code = shinyhttr::progress(session, id = "get_data_progress")
  )
})
```

The key features being that you must use `shinyhttr::progress()` rather than just `progress()`, you must pass your shiny app's session ID (by default it is just called `session`), and you must give your shinyhttr progress bar an id (in this case, `get_data_progress`).

Next step is to add the progress bar to your UI, which might look like this:

```{r shiny_progress_code_example2, eval = FALSE}
shinyWidgets::progressBar(
  id = "get_data_progress",
  value = 0,
  title = "",
  display_pct = TRUE
)
```

Note how the id in the UI code matches the id in the `eventReactive()`.

Final note, the `shiny_progress_code` argument will still produce a progress bar in a shiny app even if `cloud_mode = TRUE`; i.e., only the regular `httr::progress()` that prints to the console will be suppressed when `cloud_mode = TRUE`.
