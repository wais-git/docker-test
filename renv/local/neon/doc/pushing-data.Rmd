---
title: "Pushing Data: A Detailed Guide"
output: 
  rmarkdown::html_vignette
editor_options:
  chunk_output_type: console
vignette: >
  %\VignetteIndexEntry{pushing-data}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

<style>
body, h1, h2, h3, h4 {
    font-family: "Roboto";
}
</style>

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

If you haven't already, please read the `installing-neon`, `getting-started` and `pulling-data` vignettes before proceeding. You can view them in a browser by typing `browseVignettes("neon")` or in RStudio with `vignette(<name_of_vignette>, package = "neon")`.

`push_smartabase()` contains several arguments that aim to make your workflow easier. This vignette will explain what the following arguments mean and how they can be used:

  * [edit_event](#edit_event)
  * [get_id / match_id_to_column](#match_id_to_column)
  * [table_fields](#table_fields)
  * [current_date_format](#current_date_format)
  * [start_date / end_date / start_time / end_time](#end_time)
  * [type](#type)
  * [cloud_mode](#cloud_mode)
  * [shiny_progress_code](#shiny_progress_code)

### edit_event {#edit_event}

We envisage that a common workflow using `push_smartabase()` will involve downloading data from Smartabase, doing analysis, and then uploading the results back up to Smartabase. And so rather than upload the results into a new record, perhaps we would like the results to populate some of the fields in the original records. This is where the `edit_event` argument comes in.

**Warning: editing events comes with significant risks if used improperly. While `edit_event = TRUE`, if you push data that does not include a given field that does in fact exist in the Smartabase form, then those fields will be overwritten with empty values in Smartabase. Read on for more details** 

In order to edit or update an existing record, you will need each record's `event_id`. This can be attained when you pull data from Smartabase, like so

```{r pull_event_id, eval = FALSE}
training_data <- pull_smartabase(
  form       = "Training Log",
  start_date = "15/04/2019",
  end_date   = "15/04/2019"
)
```

```{r pull_id, echo = FALSE}
training_data <- dplyr::tibble(
  start_date               = "15/04/2019",
  user_id            = c(37204, 37201),
  event_id           = c(2381840, 2382033),
  about              = c("Aiden Thomas", "Jamie Anderson"),
  distance           = c(2530, 5411),
  RPE                = c(5, 7),
  `Average Distance` = c(NA, NA)
)

training_data
```

We have two records with `event_id = 2381840` and `event_id = 238203`. 

Notice that the field "Average Distance" is currently empty. Let's imagine we want to populate that field with the team's average distance in metres, without creating new records. First, let's do the calculation

```{r team_avg_calc, message = FALSE}
# Need to load dplyr
library(dplyr)

avg_dist_data <- training_data %>% 
  mutate_at("Average Distance", ~ round(mean(distance), 1))

avg_dist_data
```

All we need to do now is push our `avg_dist_data` data back into our "Training Log" form, set `edit_event = TRUE` and the "Average Distance" field will be populated

```{r team_avg_push, eval = FALSE}
push_smartabase(
  df         = avg_dist_data,
  form       = "Training Log",
  edit_event = TRUE
)
```

```{r pop_up_cat, echo = FALSE}
message("Please respond to pop-up prompt")
```

Running the above code will prompt a pop-up that you will have to accept, like so

```{r screenshot_popup, echo = FALSE, out.width = "500px", fig.cap = "edit_event confirmation"}
knitr::include_graphics("../man/figures/edit_event_popup.PNG")
```

```{r push_dist_avg_success, echo = FALSE}
cat("Uploading 2 existing records in Training Log...") 
cat("|===================================================================| 100%")
message("Authentication success: (200) ok")
message("SUCCESSFULLY_IMPORTED: 2 out of 2 records successfully imported by user 12345")
```

Success! Our two records' "Average Distance" field should now be populated.

A few notes on `edit_event`:

  * The data provided to `push_smartabase()` must have a column called `event_id` in order for editing an existing record to work. You can retrieve the event IDs by pulling the data first with `pull_smartabase()`.
    + If there are any rows in your dataframe that do not have an `event_id` (i.e. `event_id = NA`), then those rows will be uploaded as new records on Smartabase in a seperate API call.
  * Editing an existing record actually overwrites the data on Smartabase -- hence the need for the confirmation pop-up. **If you miss any fields in your dataframe that do exist in the Smartabase form, those values will be deleted on Smartabase**

It is recommended that when you initially pull the data, make sure you only edit the fields of interest. Leave any other fields as is.

### get_id / match_id_to_column {#match_id_to_column}

Whenever you push data to Smartabase using `push_smartabase()`, the API requires that there exists a column called `user_id` in the dataframe which contains each athlete's Smartabase user ID.

Sometimes you may not have all of your athlete's user IDs on hand, but there are several ways to find them.

  1. Pull some data from Smartabase for the relevant athletes -- you will see that there is a column called `user_id` in the resulting dataframe
  2. Use the `get_id()` function -- see the `helper-functions-guide` vignette for further explanation
  3. Use the `get_id` and `match_id_to_column` arguments in `push_smartabase()` itself
  
This section will explore the latter option.

Imagine that you want to push some Training Log data about two athletes, Aiden Thomas and Jamie Anderson, but unfortunately you do not know their user IDs. This is the dataframe you want to push to Smartabase

```{r get_id_data, echo = FALSE}
training_data <- dplyr::tibble(
  start_date     = "15/04/2019",
  about    = c("Aiden Thomas", "Jamie Anderson"),
  distance = c(2530, 5411),
  RPE      = c(5, 7)
)

training_data
```

In this case, when calling `push_smartabase()`, all you would have to do is set `get_id = TRUE` and `match_id_to_column = 'about'`. This tells `push_smartabase()` to look on Smartabase for the user IDs of athletes named "Aiden Thomas" and "Jamie Anderson", and then supply those user IDs to the API call.

```{r get_id_example, eval = FALSE}
push_smartabase(
  df                 = training_data,
  form               = "Training Log",
  get_id             = TRUE,
  match_id_to_column = "about"
)
```

`match_id_to_column` will accept "about", "username" or "email". 

**You must ensure that a column called "about", "username" or "email" exists in the dataframe when setting `match_id_to_column` to one of these values**.

If the dataframe you are uploading to Smartabase already contains the user IDs, then you do not have to do anything. Make sure `get_id = FALSE`.

### table_fields {#table_fields}
Smartabase tables are used when you want to store multiple rows of data in one record. For example, they are prevalent in strength testing forms where an athlete is performing multiple exercises in the same session; e.g.

```{r screenshot_table, echo = FALSE, out.width = "500px", fig.cap = "edit_event confirmation"}
knitr::include_graphics("../man/figures/table_example.PNG")
```

However, dealing with Smartabase tables in R is a bit tricky. For instance, here is the structure of the data when we pull from a form that has both table and non-table fields present

```{r pull_table, eval = FALSE}
strength_data <- pull_smartabase(
  form              = "Strength Testing",
  start_date        = "15/04/2019",
  end_date          = "15/04/2019",
  filter_user_key   = "about",
  filter_user_value = c("Aiden Thomas", "Jamie Anderson")
)
```

```{r strength_data, echo = FALSE}
strength_data <- dplyr::tibble(
  start_date        = rep("15/04/2019", 6),
  user_id     = c(37204, 37204, 37204, 37201, 37201, 37201),
  about       = c("Aiden Thomas", "Aiden Thomas", "Aiden Thomas", 
                  "Jamie Anderson", "Jamie Anderson", "Jamie Anderson"),
  session_rpe = c(7, NA, NA, 8, NA, NA),
  exercise    = c("Bench Press", "Bench Press", "Bench Press", 
                  "Back Squat", "Back Squat", "Back Squat"),
  load        = c(120, 115, 110, 170, 165, 165),
  repetition  = c(3, 3, 3, 3, 3, 3),
  event_id    = c(2381840, 2381840, 2381840, 2382033, 2382033, 2382033)
)
```

```{r strength_data_print}
strength_data
```

Here "exercise", "load" and "repetition" are all table fields, whereas "session_rpe" is not -- it was only recorded once in the session. "start_date", "user_id", "about" and "event_id" are metadata that will always populate each row. You will notice that for each unique start_date and user_id pairing, the non-table field ("session_rpe") will only populate the first row.

If you are pushing data to a Smartabase form that has both table and non-table fields, your data must have this structure. Further, using the `table_fields` argument, you will need to tell `push_smartabase()` which columns in your dataframe are table fields. 

```{r push_table, eval = FALSE}
push_smartabase(
  df           = strength_data,
  form         = "Strength Testing",
  table_fields = c("exercise", "load", "repetition")
)
```

Sometimes there may be a lot of table fields -- especially in GPS forms -- and it can be annoying to have to manually supply all those names to the `table_fields` argument. But since table fields tend to be next to each other in a Smartabase form, our recommendation is to extract the names of the relevant columns by column number; e.g.

```{r gps_example, eval = FALSE}
library(dplyr)

# Imagine we have GPS data where column 10 through to 60 are table fields
gps_table_names <- gps_data %>% select(10:60) %>% names()
```

We could then supply the vector of table field names to `table_fields` in `push_smartabase()`; e.g.

```{r gps_push_table, eval = FALSE}
push_smartabase(
  df           = gps_data,
  form         = "GPS",
  table_fields = gps_table_names
)
```

#### Duplicate user_id/start_date when `table_fields = NULL`

If `table_fields = NULL` but duplicate user_id/start_date pairings are detected, the dataset will be split into separate datasets that represent those records which are the first user_id/start_date pair, and those records which are 2nd, 3rd, 4th, nth user_id/start_date pair, and each dataset will then be pushed separately.

For example, let's say we have the following dataset

```{r non_table_duplicate_example, echo = FALSE}
strength_data <- dplyr::tibble(
  start_date = c("15/04/2019", "15/04/2019", "16/04/2019",
                 "15/04/2019", "15/04/2019", "15/04/2019"),
  user_id    = c(37204, 37204, 37204, 37201, 37201, 37201),
  about      = c("Aiden Thomas", "Aiden Thomas", "Aiden Thomas", 
                 "Jamie Anderson", "Jamie Anderson", "Jamie Anderson"),
  exercise   = c("Bench Press", "Bench Press", "Bench Press", 
                 "Back Squat", "Back Squat", "Back Squat"),
  load       = c(120, 115, 110, 170, 165, 165)
) %>% 
  dplyr::arrange(start_date, user_id)
```

```{r non_table_duplicate_example2, echo = TRUE}
print(strength_data)
```

As you can see, Aiden Thomas has two records occurring on "15/04/2019" while Jamie Anderson has three records occurring on the "15/04/2019". If we try to push this data while `table_fields` is left empty, `push_smartabase()` will internally split the data like this

```{r non_table_duplicate_example3, echo = FALSE}
strength_data %>% 
  dplyr::group_by(start_date, user_id) %>% 
  dplyr::mutate(row_num = 1:dplyr::n()) %>% 
  dplyr::ungroup() %>% 
  split(.$row_num) %>% 
  purrr::map(~ .x %>% dplyr::select(-row_num))
```

The first dataset contains the records that represent the first occurrence of a particular user_id/start_date pairing, the second dataset contains the second occurrence of a particular user_id/start_date pairing, the third dataset contains the third occurrence of a particular user_id/start_date pairing, and so on.

From a user's perspective, what you would see is something like this:

```{r non_table_duplicate_example4, eval = FALSE}
push_smartabase(
  df   = strength_data,
  form = "Strength Testing"
)
```

```{r non_table_duplicate_example5, echo = FALSE}
cat("Uploading 3 new records to Strength Testing...") 
cat("|===================================================================| 100%")
message("Authentication success: (200) ok")
message("SUCCESSFULLY_IMPORTED: 3 out of 3 records successfully imported by user 12345")
```

```{r non_table_duplicate_example6, echo = FALSE}
cat("Uploading 2 new records to Strength Testing...") 
cat("|===================================================================| 100%")
message("Authentication success: (200) ok")
message("SUCCESSFULLY_IMPORTED: 2 out of 2 records successfully imported by user 12345")
```

```{r non_table_duplicate_example7, echo = FALSE}
cat("Uploading 1 new records to Strength Testing...") 
cat("|===================================================================| 100%")
message("Authentication success: (200) ok")
message("SUCCESSFULLY_IMPORTED: 1 out of 1 records successfully imported by user 12345")
```

### current_date_format {#current_date_format}

If there is a date column in your data (e.g. "date", "start_date" or "end_date"), it must be in dd/mm/yyyy format (i.e. dmy format). If, say, your date column is actually in mdy format, then rather than having to convert to dmy yourself, you can simply supply `current_date_format = "mdy"` in `push_smartabase()` and the relevant date columns will automatically convert to dmy format; e.g.

```{r date_conversion_data, echo = FALSE}
example_mdy_data <- tibble(
  date          = "01/31/2019",
  user_id       = 37204,
  example_field = "test data"
)
```

```{r date_conversion_data_print}
example_mdy_data
```

```{r date_conversion, eval = FALSE}
push_smartabase(
  df                  = example_mdy_data,
  form                = "Example form",
  current_date_format = "mdy"
)
```

`current_date_format` will accept the following values: **"mdy", "ymd", "ydm", "myd" or "dym"**. 

If the format you choose does not match the format of the dates in your data, the conversion will fail. 

Likewise, the conversion will fail if multiple date formats are detected in the data (including if there are missing values), so you must ensure that the date format is uniform across the data. 

If the conversion fails, you can inspect which rows failed via the "log_file.txt" that will appear in your working directory. 

### start_date / end_date / start_time / end_time {#end_time}

When uploading data to Smartabase, the API requires metadata about when the event started and stopped. `push_smartabase()` has several arguments to delineate the start and end of an event by virtue of the `start_date`, `end_date`, `start_time` and `end_time` arguments.

By default, you don't have to supply any values to these arguments. 

If `start_time` and `end_time` are `NULL` (i.e. not supplied), `push_smartabase()` will first search for any columns in the data named "start_time" and "end_time". If they exist, the data found in those columns will be used for `start_time` and `end_time`. If those columns do not exist, `start_time` and `end_time` will be set to the current time and one hour after the current time, respectively. **Note: start and end time must be in h:mm AM or h:mm PM format.**

Likewise, if `start_date` and `end_date` are `NULL`, `push_smartabase()` will first seach for any columns named "date", "start_date" or "end_date". If they exist, the data found in those columns will be used for `start_date` and `end_date`. If those columns do not exist, both `start_date` and `end_date` will be set to the current date (unless the difference between `start_time` and `end_time` spans midnight, in which case the `end_date` will be set to the current date plus one day).

Alternatively, you may have some existing date / time columns in your dataframe which are not named `start_date`, `end_date`, `start_time` and/or `end_time`. You could rename the columns, or instead supply the column names to `start_date`, `start_time` etc. in the `push_smartabase()` call. 

```{r metadata_data, echo = FALSE}
example_data <- tibble(
  user_id       = 37204,
  example_field = "test data",
  date1         = "14/03/2019",
  date2         = "14/03/2019",
  time1         = "09:00 AM",
  time2         = "09:30 AM"
)
```

```{r metadata_data_print}
example_data
```

Note our `start_date`, `end_date`, `start_time` and `end_time` columns are actually called "date1", "date2", "time1" and "time2", respectively. Here's how the `push_smartabase()` call would look.

```{r metadata_push, eval = FALSE}
push_smartabase(
  df         = example_data,
  form       = "Example form",
  start_date = "date1",
  end_date   = "date2",
  start_time = "time1",
  end_time   = "time2"
)
```

Note that if any of the start/end date/time columns you provide are of the wrong format (i.e. they are not dd/mm/yyyy dates or h:mm AM or h:mm PM times), then an error will occurr. You can inspect which rows failed via the “log_file.txt” that will appear in your working directory.

### type {#type}

Similar to how you can download profile form data by setting `type = "profile` within `pull_smartabase()`, you can upload profile data by setting `type = "profile` within `push_smartabase()`. Let's say we want to upload some profile data to the "Athlete Profile" form for Aiden Thomas

```{r profile_data, echo = FALSE}
profile_data <- tibble(
  user_id = 37204,
  about   = "Aiden Thomas",
  gender  = "Male",
  Height  = 184,
  Weight  = 81
)
```

```{r profile_data_print}
profile_data
```

```{r profile_push, eval = FALSE}
push_smartabase(
  df   = profile_data,
  form = "Athlete Profile",
  type = "profile"
)
```

**Note: profile forms only contain one record per athlete. If an athlete already has data against them in a profile form, be wary that pushing more profile data for that athlete will overwrite the existing profile data.**

You will notice that if you try to push multiple rows of profile data in one `push_smartabase()` call, each row is uploaded separately (i.e. you will get separate status messages for each row). This is because the Smartabase API only allows one profile record to be uploaded at one time. This is not something you have to worry about -- i.e. if `push_smartabase()` detects there are multiple rows in your dataframe while `type = "profile"`, your dataframe will be automatically split by row and the API will be called to upload each row separately.

### cloud_mode {#cloud_mode}

`push_smartabase()` accepts an input called `cloud_mode`. If `cloud_mode = TRUE`, no progress bar will be printed to screen and no confirmation pop-up will appear when `edit_event = TRUE`. This is for when the package is being run on cloud instances in an automated fashion. Furthermore, any error logs are printed rather than saved to a text file.

### shiny_progress_code {#shiny_progress_code}

You will notice that when you push data with push_smartabase(), a progress bar will appear in the console that roughly displays the percentage of data left to upload. 

It would be useful if this progress bar can be passed to shiny apps that utilise push_smartabase(), given the typical way to show progress bars in shiny is to essentially fake it; that is, to step the progress bar according to some arbitrary function that doesn't actually represent the state of the upload – see [here](https://shiny.rstudio.com/articles/progress.html).

The problem is that the progress bar in push_smartabase() is printed to screen, but to work with a shiny app it needs to accept the shiny app's session ID. Thankfully, there is a package called `shinyhttr` that achieves this: [shinyhttr github](https://github.com/curso-r/shinyhttr).

To pass the progress bar to a shinyapp, you firstly must install `shinyhttr` and `shinyWidgets` and load them in your app. Second, you must pass the bare `shinyhttr` code for producing a shiny progress bar to the `shiny_progress_code` argument in `push_smartabase()`. Let's say you also have a button called `push_data` in your app, where clicking on that button triggers `push_smartabase()`. Your reactive function for pushing data in a shiny app might then look like this:

```{r shiny_progress_code_example, eval = FALSE}
output_data <- eventReactive(input$push_data, {
  push_smartabase(
    df = "example_data",
    form = "Example form",
    shiny_progress_code = shinyhttr::progress(session, id = "push_data_progress")
  )
})
```

The key features being that you must use `shinyhttr::progress()` rather than just `progress()`, you must pass your shiny app's session ID (by default it is just called `session`), and you must give your shinyhttr progress bar an id (in this case, `push_data_progress`).

Next step is to add the progress bar to your UI, which might look like this:

```{r shiny_progress_code_example2, eval = FALSE}
shinyWidgets::progressBar(
  id = "push_data_progress",
  value = 0,
  title = "",
  display_pct = TRUE
)
```

Note how the id in the UI code matches the id in the `eventReactive()`.

Final note, the `shiny_progress_code` argument will still produce a progress bar in a shiny app even if `cloud_mode = TRUE`; i.e., only the regular `httr::progress()` that prints to the console will be suppressed when `cloud_mode = TRUE`.
